# Tecnologias e Guia de Desenvolvimento - Frontend

Este documento especifica as tecnologias, arquitetura e padrões recomendados para o desenvolvimento do frontend do aplicativo Notikfy. O frontend é um dashboard simples com autenticação via Google, suporte para desktop e mobile (inicialmente como Progressive Web App - PWA), integração com Firebase (para auth, dados e hosting) e configurações para webhooks do TikTok e notificações via Telegram.

O foco é em simplicidade, performance, responsividade e desenvolvimento rápido. O frontend será construído como uma Single Page Application (SPA) para uma experiência fluida, com suporte a PWA para instalação em mobile e acesso offline parcial.

## Framework Principal

### React
- **Versão**: 18 ou superior
- **Motivo**: Framework JavaScript leve e reativo para construção de interfaces componentizadas. Facilita gerenciamento de estado e integração com Firebase.
- **Uso**: Componentes para dashboard, formulários e exibição de dados em tempo real.

### Ferramenta de Build
- **Vite**: Recomendado para builds rápidos e hot reloading otimizado
- **Alternativa**: Create React App (CRA) se preferir setup mais tradicional
- **Motivo**: Vite oferece melhor performance de desenvolvimento e build mais rápido

### TypeScript
- **Versão**: 5.0 ou superior
- **Motivo**: Tipagem estática para evitar erros em runtime, especialmente com Firebase SDK e componentes MUI.
- **Configuração**: Usar `strict: true` no `tsconfig.json` para máxima segurança de tipos.

## Arquitetura e Estrutura de Pastas

```
src/
├── components/              # Componentes reutilizáveis
│   ├── common/             # Componentes comuns (Button, Card, etc.)
│   ├── layout/             # Componentes de layout (Header, Sidebar, etc.)
│   └── forms/              # Componentes de formulário
├── pages/                   # Telas/rotas da aplicação
│   ├── Login/
│   ├── Dashboard/
│   ├── Settings/
│   └── Sales/
├── hooks/                   # Custom React hooks
│   ├── useAuth.ts
│   ├── useSales.ts
│   └── useFirestore.ts
├── services/                # Integrações e lógica de negócios
│   ├── firebase/
│   │   ├── auth.service.ts
│   │   ├── firestore.service.ts
│   │   └── config.ts
│   └── api/                # Chamadas HTTP (se necessário)
├── context/                 # Contextos React
│   ├── AuthContext.tsx
│   └── ThemeContext.tsx
├── utils/                   # Funções utilitárias
│   ├── formatters.ts
│   ├── validators.ts
│   └── constants.ts
├── types/                   # TypeScript interfaces e types
│   ├── user.types.ts
│   ├── sale.types.ts
│   └── api.types.ts
├── styles/                  # Estilos globais e temas
│   ├── theme.ts            # Tema do MUI
│   └── global.css
├── App.tsx                  # Componente raiz
├── main.tsx                 # Entry point
└── router.tsx               # Configuração de rotas
```

## Integração com Firebase

### Firebase SDK
- **Pacotes**: `firebase` (inclui auth, firestore, etc.)
- **Motivo**: Para autenticação (Google Sign-in), queries real-time no Firestore e hosting.
- **Uso**: 
  - Hooks como `useAuthState` para gerenciar login
  - Listeners para updates de vendas em tempo real
  - Queries para buscar dados do Firestore

### Configuração
Criar arquivo `src/services/firebase/config.ts`:

```typescript
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  // ... outras configs
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const db = getFirestore(app);
```

## Gerenciamento de Estado e Dados

### React Hooks Nativos
- **Hooks utilizados**: `useState`, `useEffect`, `useContext`, `useMemo`, `useCallback`
- **Motivo**: Suficiente para estado local e contexto global. Evita overhead de bibliotecas externas para casos simples.

### React Query (Recomendado)
- **Pacote**: `@tanstack/react-query` (anteriormente react-query)
- **Versão**: Última estável
- **Motivo**: 
  - Caching de dados do Firestore
  - Handling de loading/errors states
  - Otimização de performance (reduz requisições desnecessárias)
  - Refetch automático e sincronização em background
- **Uso**: Para queries de dados do Firestore e sincronização em tempo real

### Context API
- **Motivo**: Para estado global compartilhado (autenticação, tema, configurações)
- **Uso**: Criar contextos específicos (AuthContext, ThemeContext) em vez de um único contexto grande

## Roteamento e Navegação

### React Router
- **Pacote**: `react-router-dom`
- **Versão**: 6.x ou superior
- **Motivo**: Para navegação entre telas (ex.: login, dashboard, configurações).
- **Uso**: 
  - Rotas protegidas com auth guards
  - Lazy loading de rotas para code splitting
  - Navegação programática

### Exemplo de Roteamento

```typescript
import { lazy } from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { ProtectedRoute } from './components/auth/ProtectedRoute';

const Login = lazy(() => import('./pages/Login'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Settings = lazy(() => import('./pages/Settings'));

export function AppRouter() {
  return (
    <Routes>
      <Route path="/login" element={<Login />} />
      <Route
        path="/dashboard"
        element={
          <ProtectedRoute>
            <Dashboard />
          </ProtectedRoute>
        }
      />
      <Route
        path="/settings"
        element={
          <ProtectedRoute>
            <Settings />
          </ProtectedRoute>
        }
      />
      <Route path="/" element={<Navigate to="/dashboard" replace />} />
    </Routes>
  );
}
```

## Estilização e UI Components

### Material-UI (MUI)
- **Pacote**: `@mui/material`, `@mui/icons-material`
- **Versão**: 5.x ou superior (MUI v5+)
- **Motivo**: Biblioteca de componentes prontos (botões, forms, tables, cards) com theming responsivo e acessibilidade. Design system consistente e moderno.
- **Uso**: 
  - Componentes principais da UI (Button, TextField, Card, Table, etc.)
  - Sistema de grid responsivo
  - Temas customizáveis
  - Ícones através de @mui/icons-material

### Instalação e Configuração

```bash
npm install @mui/material @emotion/react @emotion/styled
npm install @mui/icons-material
```

### Tema Customizado

Criar arquivo `src/styles/theme.ts`:

```typescript
import { createTheme } from '@mui/material/styles';

export const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
  },
  components: {
    // Customizações de componentes
  },
});
```

### Uso de Componentes MUI

```typescript
import { Button, TextField, Card, CardContent, Typography } from '@mui/material';
import { Delete as DeleteIcon } from '@mui/icons-material';

function MyComponent() {
  return (
    <Card>
      <CardContent>
        <Typography variant="h5">Título</Typography>
        <TextField label="Nome" variant="outlined" fullWidth />
        <Button 
          variant="contained" 
          color="primary"
          startIcon={<DeleteIcon />}
        >
          Deletar
        </Button>
      </CardContent>
    </Card>
  );
}
```

### Regras de Estilização

- **Evitar CSS inline**: Usar classes do MUI ou styled components
- **Usar sistema de tema**: Customizar cores e estilos através do tema, não hardcode
- **Responsividade**: Usar breakpoints do MUI (`useMediaQuery`, `sx` prop)
- **Espaçamento**: Usar sistema de spacing do MUI (theme.spacing())

## Formulários e Validação

### React Hook Form
- **Pacote**: `react-hook-form`
- **Versão**: Última estável
- **Motivo**: Gerenciamento eficiente de forms com validações integradas e performance otimizada (menos re-renders).
- **Uso**: Para inputs de código de acesso, configs TikTok e Telegram (token e chat ID).

### Validação
- **Yup** ou **Zod**: Para schema validation (recomendado usar com react-hook-form)
- **Integração com MUI**: Usar `Controller` do react-hook-form para componentes MUI

### Exemplo de Formulário

```typescript
import { useForm, Controller } from 'react-hook-form';
import { TextField, Button } from '@mui/material';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const schema = yup.object({
  telegramToken: yup.string().required('Token é obrigatório'),
  chatId: yup.string().required('Chat ID é obrigatório'),
});

function SettingsForm() {
  const { control, handleSubmit } = useForm({
    resolver: yupResolver(schema),
  });

  const onSubmit = (data: any) => {
    // Salvar configurações
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Controller
        name="telegramToken"
        control={control}
        render={({ field, fieldState: { error } }) => (
          <TextField
            {...field}
            label="Token do Telegram"
            error={!!error}
            helperText={error?.message}
            fullWidth
          />
        )}
      />
      <Button type="submit" variant="contained">Salvar</Button>
    </form>
  );
}
```

## Notificações In-App e Utilitários

### React Toastify
- **Pacote**: `react-toastify`
- **Motivo**: Para feedback visual in-app (ex.: "Configurações salvas com sucesso").
- **Uso**: Complementa notificações externas via Telegram.

### Instalação e Uso

```typescript
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

function App() {
  return (
    <>
      <ToastContainer position="top-right" />
      {/* ... resto do app */}
    </>
  );
}

// Usar toast
toast.success('Configurações salvas!');
toast.error('Erro ao salvar');
```

## Suporte a PWA (para Mobile e Desktop)

### Vite PWA Plugin
- **Pacote**: `vite-plugin-pwa`
- **Motivo**: Transforma o app em PWA para instalação em mobile, suporte offline e notificações web (se necessário no futuro).
- **Uso**: Gera manifest.json e service workers para caching de assets.

### Configuração no vite.config.ts

```typescript
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      manifest: {
        name: 'Notikfy',
        short_name: 'Notikfy',
        description: 'Dashboard de notificações TikTok',
        theme_color: '#1976d2',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          // ... outros ícones
        ]
      }
    })
  ]
});
```

## Tipagem e Qualidade de Código

### TypeScript
- **Interfaces e Types**: Defina interfaces para props, estados e dados do Firestore
- **Tipos de Componentes**: Use tipos do React (`React.FC` ou inferência)
- **Tipos do Firebase**: Use tipos do Firebase SDK quando disponíveis

### Exemplo de Tipos

```typescript
// types/sale.types.ts
export interface Sale {
  id: string;
  userId: string;
  orderId: string;
  productName: string;
  amount: number;
  currency: string;
  status: 'pending' | 'completed' | 'refunded';
  createdAt: Timestamp;
}

export interface SaleFormData {
  productName: string;
  amount: number;
}
```

### ESLint + Prettier
- **Motivo**: Manter código limpo, consistente e sem erros.
- **Configuração**: 
  - ESLint com plugins para React, TypeScript e MUI
  - Prettier com configuração padronizada
  - Integração com editor para format on save

## Requisições HTTP (se necessário)

### Fetch API Nativo
- **Preferido**: Fetch API nativo do navegador
- **Motivo**: Sem dependências adicionais, suportado nativamente

### Axios (Opcional)
- **Pacote**: `axios`
- **Motivo**: Para chamadas extras (ex.: testar webhooks), mas Firebase SDK cobre a maioria das necessidades.
- **Uso**: Apenas se precisar de interceptors ou features avançadas

## Dependências de Desenvolvimento

- **Node.js**: Versão 18+ (para runtime)
- **npm ou Yarn**: Para gerenciamento de pacotes
- **Firebase CLI**: Para deploy no Hosting e emuladores locais
- **TypeScript**: Compilador TypeScript
- **Vite**: Build tool
- **ESLint**: Linter
- **Prettier**: Formatação
- **Jest + React Testing Library**: Testes

## Variáveis de Ambiente

Criar arquivo `.env.example`:

```bash
VITE_FIREBASE_API_KEY=your-api-key
VITE_FIREBASE_AUTH_DOMAIN=your-auth-domain
VITE_FIREBASE_PROJECT_ID=your-project-id
VITE_FIREBASE_STORAGE_BUCKET=your-storage-bucket
VITE_FIREBASE_MESSAGING_SENDER_ID=your-sender-id
VITE_FIREBASE_APP_ID=your-app-id
```

**Importante**: 
- Variáveis no Vite devem ter prefixo `VITE_`
- Nunca commitar arquivo `.env` com valores reais

## Convenções de Código

### Nomenclatura
- **Componentes**: `PascalCase` (ex: `Dashboard`, `SettingsForm`)
- **Hooks**: `camelCase` com prefixo `use` (ex: `useAuth`, `useSales`)
- **Funções/Variáveis**: `camelCase` (ex: `handleSubmit`, `formatDate`)
- **Constantes**: `UPPER_SNAKE_CASE` (ex: `MAX_RETRY_ATTEMPTS`)
- **Arquivos**: 
  - Componentes: `PascalCase.tsx` (ex: `Dashboard.tsx`)
  - Utilitários: `camelCase.ts` (ex: `formatDate.ts`)

### Organização de Componentes

Cada componente deve ter sua própria pasta quando necessário:

```
components/
└── SaleCard/
    ├── SaleCard.tsx
    ├── SaleCard.test.tsx
    └── index.ts
```

### Organização de Imports
1. Bibliotecas externas (React, MUI, Firebase)
2. Bibliotecas internas/compartilhadas
3. Componentes
4. Hooks
5. Utilitários
6. Types/Interfaces
7. Arquivos relativos

### Tratamento de Erros

Usar Error Boundaries para capturar erros de renderização:

```typescript
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error }: { error: Error }) {
  return (
    <div role="alert">
      <Typography color="error">Algo deu errado:</Typography>
      <Typography>{error.message}</Typography>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      {/* ... componentes */}
    </ErrorBoundary>
  );
}
```

## Testes

### Jest + React Testing Library
- **Pacote**: `@testing-library/react`, `@testing-library/jest-dom`
- **Motivo**: Testes de componentes React focados em comportamento do usuário
- **Cobertura**: Almejar pelo menos 70% para componentes críticos

### Exemplo de Teste

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '@mui/material';

describe('Button', () => {
  it('should render button with text', () => {
    render(<Button>Clique aqui</Button>);
    expect(screen.getByText('Clique aqui')).toBeInTheDocument();
  });

  it('should call onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Clique</Button>);
    fireEvent.click(screen.getByText('Clique'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### Testes de Integração
- Testar fluxos completos (ex.: login → dashboard → settings)
- Usar Firebase Emulators para testes com Firestore/Auth

## Performance e Otimização

### Code Splitting
- Usar `React.lazy()` para lazy loading de rotas
- Separar bundles grandes em chunks menores

```typescript
const Dashboard = lazy(() => import('./pages/Dashboard'));
```

### Memoização
- Usar `React.memo()` para componentes que re-renderizam frequentemente
- Usar `useMemo()` e `useCallback()` quando apropriado

### Otimização de Imagens
- Lazy load de imagens
- Usar formatos modernos (WebP) quando possível
- Otimizar tamanho de imagens

### Queries do Firestore
- Paginar resultados grandes
- Usar índices compostos quando necessário
- Limitar campos retornados (use `select()`)

## Acessibilidade

### Princípios
- Usar elementos semânticos do HTML
- Adicionar labels apropriados
- Garantir navegação por teclado
- Usar cores com contraste adequado

### MUI e Acessibilidade
- MUI já implementa muitas práticas de acessibilidade
- Usar componentes acessíveis do MUI
- Testar com screen readers

## Instalação e Setup Inicial

### Passo a Passo

1. **Crie o projeto com Vite**:
   ```bash
   npm create vite@latest notikfy-frontend -- --template react-ts
   cd notikfy-frontend
   ```

2. **Instale dependências principais**:
   ```bash
   npm install react-router-dom firebase @mui/material @emotion/react @emotion/styled
   npm install @mui/icons-material @tanstack/react-query react-hook-form react-toastify
   npm install vite-plugin-pwa -D
   ```

3. **Instale dependências de validação** (opcional):
   ```bash
   npm install yup @hookform/resolvers
   ```

4. **Configure MUI Theme**: Crie `src/styles/theme.ts` e envolva o app com `ThemeProvider`

5. **Configure Firebase**: Crie arquivo de configuração em `src/services/firebase/config.ts`

6. **Configure Rotas**: Crie estrutura de rotas em `src/router.tsx`

7. **Configure PWA**: Adicione plugin PWA no `vite.config.ts`

8. **Configure variáveis de ambiente**: Crie `.env.example` e `.env.local`

9. **Teste localmente**:
   ```bash
   npm run dev
   ```

10. **Deploy no Firebase Hosting**:
    ```bash
    npm run build
    firebase deploy --only hosting
    ```

## Considerações Finais

### Performance
- Use code splitting (React.lazy) para bundles menores
- Teste responsividade em dispositivos reais
- Monitore performance com React DevTools Profiler

### Segurança
- Armazene tokens sensíveis (ex.: Telegram) apenas no backend/Firestore, não no frontend
- Valide inputs no frontend, mas sempre valide também no backend
- Use Firebase Security Rules para proteger dados

### Escalabilidade
- Mantenha componentes pequenos e reutilizáveis
- Use custom hooks para lógica compartilhada
- Organize código em módulos bem definidos

### Versões
- Use as mais recentes estáveis para compatibilidade com Firebase (verifique changelogs em 2025)
- Mantenha dependências atualizadas para segurança

### UX/UI
- Priorize harmonia de espaços e elementos
- Mantenha consistência visual usando tema MUI
- Teste em diferentes tamanhos de tela
- Implemente loading states e feedback visual

Este setup permite um MVP funcional em poucos dias, com custos mínimos no Firebase Hosting. Ajustes podem ser feitos com base em requisitos específicos.
